\documentclass{article}

% Symbols
\usepackage{amsfonts, amsthm}
\usepackage{upgreek}
\usepackage{physics}
\usepackage{cancel}
\usepackage{amssymb, latexsym, amsmath}

%Algorithms
\usepackage[ruled,lined,linesnumbered,commentsnumbered]{algorithm2e}

%% Identación
\setlength{\parindent}{0cm}

% Código
\newcommand{\code}[1]{\textcolor{white!25!black}{\texttt{#1}}}
\usepackage{listings}

%AMS
\usepackage{amsthm}
\newtheorem{algo-thm}{Algoritmo}

% Proof
\renewcommand*{\proofname}{\textbf{Demostraci\'on:}}
% Theorem
\newtheorem*{theorem}{Teorema}

% Graphics
\usepackage{graphicx}
\usepackage{pgf}

% Color a letras.
%\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

% << >>
\usepackage[T1]{fontenc}

% Tikz
\usepackage{tkz-graph}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
%\usetikzlibrary[topaths]

% Def. Dr. César.
\usetikzlibrary{shapes,calc}
\tikzstyle{edge}=[shorten <=2pt, shorten >=2pt, >=stealth, line width=1.1pt]
\tikzstyle{blueE}=[shorten <=2pt, shorten >=2pt, >=stealth, line width=1.5pt, blue]
\tikzstyle{blackV}=[circle, fill=black, minimum size=6pt, inner sep=0pt, outer sep=0pt]
\tikzstyle{blueV}=[circle, fill=blue, draw, minimum size=6pt, line width=0.75pt, inner sep=0pt, outer sep=0pt]
\tikzstyle{redV}=[circle, fill=red, draw, minimum size=6pt, line width=0.75pt, inner sep=0pt, outer sep=0pt]
\tikzstyle{redSV}=[semicircle, fill=red, minimum size=3pt, inner sep=0pt, outer sep=0pt, rotate=225]
\tikzstyle{blueSV}=[semicircle, fill=blue, minimum size=3pt, inner sep=0pt, outer sep=0pt, rotate=225]
\tikzstyle{blackSV}=[semicircle, fill=black, minimum size=3pt, inner sep=0pt, outer sep=0pt, rotate=225]
\tikzstyle{vertex}=[circle, draw, minimum size=6pt, line width=0.75pt, inner sep=0pt, outer sep=0pt]

% Margins
\addtolength{\voffset}{-1.5cm}
\addtolength{\hoffset}{-1.5cm}
\addtolength{\textwidth}{3cm}
\addtolength{\textheight}{3cm}

%Header-Footer
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{1pt}

\newcommand{\set}[1]{
  \left\{ #1 \right\}
}

%\pagenumbering{gobble} -- Este comando
%                       -- quita el número de página.
\footskip = 50pt
\renewcommand{\headrulewidth}{1pt}

\pagestyle{fancyplain}

\begin{document}
\title{UNIVERSIDAD AUT\'ONOMA DE M\'EXICO\\ Facultad de Ciencias}
\author{Autor: Adri\'an Aguilera Moreno}
\date{}
\maketitle
\begin{center}
  \includegraphics[scale=0.20]{../Imagen/Portada.jpg}\\[0.4cm]
  \Large
  \bf{Lógica Computacional}
  \normalsize
\end{center}
\newpage
\fancyhead[r]{ Lógica Computacional 2022-2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{\LARGE{Semanal 3}}
Para cada uno de los siguientes ejercicios, \textbf{justifica ampliamente} tu respuesta.
\begin{enumerate}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ejercicio 01
\item \textbf{Realiza} las siguientes sustituciones \textbf{eliminando} los paréntesis
  superfluos en el resultado y \textbf{mostrando paso a paso} el procedimiento.
  \begin{itemize}
  \item[$a$)] $((q \lor r)[q, p := \neg p, s] \rightarrow (r \land \neg(r \leftrightarrow p)))[p, r, q := r \lor q, q \land p, s]$.
  \item[$b$)] $(u \lor t) \rightarrow (\neg r \leftrightarrow (u \leftrightarrow s))[r, u, t := u, t, r]$.
  \end{itemize}
  $\triangledown$ \textbf{Solución:} Analizando los incisos tenemos que
  
  \begin{itemize}
  \item[$a$)] Sea $\alpha = [q, p := \neg p, s]$ y $\beta = [p, r, q := r \lor q, q \land p, s]$, entonces
    \begin{eqnarray*}
      ((q \lor r)\alpha \rightarrow (r \land \neg(r \leftrightarrow p)))\beta
      &=& ((q\alpha \lor r\alpha) \rightarrow (r \land \neg(r \leftrightarrow p)))\beta\\
      &=& ((\neg p \lor r) \rightarrow (r \land \neg(r \leftrightarrow p)))\beta\\
      &=& ((\neg p \lor r)\beta \rightarrow (r \land \neg(r \leftrightarrow p))\beta)\\
      &=& \neg p\beta \lor r\beta \rightarrow r\beta \land \neg(r \leftrightarrow p)\beta\\
      &=& \neg (r \lor q) \lor (q \land p) \rightarrow (q \land p) \land \neg(r\beta \leftrightarrow p\beta)\\
      &=& \neg (r \lor q) \lor (q \land p) \rightarrow (q \land p) \land \neg(q \land p \leftrightarrow r \lor q)
    \end{eqnarray*}
  \item[$b$)] Sea $\alpha = [r, u, t := u, t, r]$, entonces
    \begin{eqnarray*}
      (u \lor t) \rightarrow (\neg r \leftrightarrow (u \leftrightarrow s))\alpha
      &=& (u \lor t) \rightarrow (\neg r\alpha \leftrightarrow (u \leftrightarrow s)\alpha)\\
      &=& (u \lor t) \rightarrow (\neg u \leftrightarrow (u\alpha \leftrightarrow s\alpha))\\
      &=& (u \lor t) \rightarrow (\neg u \leftrightarrow (t \leftrightarrow s))\\
      &=& u \lor t \rightarrow (\neg u \leftrightarrow (t \leftrightarrow s))
    \end{eqnarray*}    
  \end{itemize}
  \hfill $\lhd$
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ejercicio 02
\item
  \begin{itemize}
  \item[$a$)] \textbf{Define recursivamente} la función $pa$ que dada una fórmula $\varphi$, devuelve el número
    de paréntesis abiertos ``$($'' que tiene $\varphi$.
  \item[$b$)] \textbf{Define recursivamente} la función $pc$ que dada una fórmula $\varphi$, devuelve el número
    de paréntesis cerrados ``$)$'' que tiene $\varphi$.
  \item[$c$)] Sea $\varphi = (((\neg p \land q) \lor \neg r) \rightarrow r)$. Demuestra que
    \[
    pa(\varphi) - pc(\varphi) = 0
    \]
  \end{itemize}
\end{enumerate}
$\triangledown$ \textbf{Solución:}
\begin{itemize}
  \item[$a$)] Definimos $pa: PROP \cup \{\land, \lor, \neg, \rightarrow, \leftrightarrow, (, )\} \rightarrow \mathbb{N} \cup \{0\}$.
  Así, para
  \[
  \varphi \in ATOM \cup \{\land, \lor, \neg, \rightarrow, \leftrightarrow, )\}
  \]
  se tiene que $pa(\varphi) = 0$. También, $pa\big((\big) = 1$. Para $\alpha, \mu \in PROP$ se tiene que
  \begin{eqnarray*}
    pa\big((\alpha)\big) &=& pa\big((\big) + pa(\alpha) + pa\big()\big)\\
    pa(\neg \alpha) &=& pa(\neg) + pa(\alpha)\\
    pa(\alpha * \mu) &=& pa(\alpha) + pa(*) + pa(\mu)
  \end{eqnarray*}
  donde $* \in \{\land, \lor, \neg, \rightarrow, \leftrightarrow\}$.
\item[$b$)] Definimos $pc: PROP \cup \{\land, \lor, \neg, \rightarrow, \leftrightarrow, (, )\} \rightarrow \mathbb{N} \cup \{0\}$.
  Así, para
  \[
  \varphi \in ATOM \cup \{\land, \lor, \neg, \rightarrow, \leftrightarrow, (\}
  \]
  se tiene que $pc(\varphi) = 0$. También, $pc\big()\big) = 1$. Para $\alpha, \mu \in PROP$ se tiene que
  \begin{eqnarray*}
    pc\big((\alpha)\big) &=& pc\big((\big) + pc(\alpha) + pc\big()\big)\\
    pc(\neg \alpha) &=& pc(\neg) + pc(\alpha)\\
    pc(\alpha * \mu) &=& pc(\alpha) + pc(*) + pc(\mu)    
  \end{eqnarray*}
  donde $* \in \{\land, \lor, \neg, \rightarrow, \leftrightarrow\}$.
\item[$c$)] Veamos que
  \begin{eqnarray*}
    pa\big((((\neg p \land q) \lor \neg r) \rightarrow r)\big)  &=&
    pa\big((\big) + pa\big(((\neg p \land q) \lor \neg r) \rightarrow r\big) + pa\big()\big)\\
    &=& 1 + pa\big(((\neg p \land q)\lor \neg r)\big) + pa(\rightarrow) + pa(r)\\
    &=& 1 + pa\big((\big) + pa\big((\neg p \land q)\big) + pa(\lor) + pa(\neg r) + pa\big()\big)\\
    &=& 2 + pa\big((\big) + pa\big(\neg p \land q\big) + pa\big()\big) + pa(\neg) + pa(r)\\
    &=& 3 + pa(\neg p) + pa(\land) + pa(q)\\
    &=& 3 + pa(\neg) + pa(p)\\
    &=& 3
  \end{eqnarray*}
  además, se tiene que
  \begin{eqnarray*}
    pc((((\neg p \land q) \lor \neg r) \rightarrow r)) &=&
    pc\big((\big) + pc\big(((\neg p \land q) \lor \neg r) \rightarrow r\big) + pc\big()\big)\\
    &=& pc\big(((\neg p \land q)\lor \neg r)\big) + pc(\rightarrow) + pc(r) + 1\\
    &=& pc\big((\big) + pc\big((\neg p \land q)\big) + pc(\lor) + pc(\neg r) + pc\big()\big) + 1\\
    &=& pc\big((\big) + pc\big(\neg p \land q\big) + pc\big()\big) + pc(\neg) + pc(r) + 2\\
    &=& pc(\neg p) + pc(\land) + pc(q) + 3\\
    &=& pc(\neg) + pc(p) + 3\\
    &=& 3
  \end{eqnarray*}
  Luego, es claro que
  \begin{eqnarray*}
    pa((((\neg p \land q) \lor \neg r) \rightarrow r)) - pc((((\neg p \land q) \lor \neg r) \rightarrow r))
    &=& 3 - 3\\
    &=& 0
  \end{eqnarray*}
\end{itemize}
\hfill $\lhd$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ejercicio extra
\textbf{Desafío extra...}
\renewcommand{\labelitemi}{$-$}
\begin{itemize}
\item \textbf{Define recursivamente} una función compress que elimina los elementos consecutivos
  repetidos de una lista.
  
  Ejemplo:
  \begin{center}
    \code{compress([a,a,a,a,i,i,i,u,d,d,d,d,d,a,a,a,a,a,a,a]) = [a,i,u,d,a]}
  \end{center}
  
  $\triangledown$ \textbf{Solución:} Para este inciso definimos una función auxiliar que nos
  indique si un elemento arbitrario esta contenido en una lista, esto es
  \begin{equation*}
    \label{eq:aqui-le-mostramos-como-hacerle-la-llave-grande}
    \code{contains(x:xs, a)}\footnote{\code{contains:[\_] $\rightarrow$ [\_]}.} = \left\{
    \begin{array}{ll}
      \code{true}           & \mathrm{si\ } \code{x} = \code{a} \\
      \code{false}            & \mathrm{si\ } \code{x} = \phi \\
      \code{contains(s, a)}  & \mathrm{si\ } \code{x} \neq \code{a}
    \end{array}
    \right.
  \end{equation*}
  
  Ahora definamos la función \code{compress:[\_] $\rightarrow$ [\_]}, esto es
  
  \begin{equation*}
    \label{eq:aqui-le-mostramos-como-hacerle-la-llave-grande}
    \code{compress(x:xs)} = \left\{
    \begin{array}{ll}
      \code{compress(s)}            & \mathrm{si\ } \code{contains(s, x)} = \code{true} \\
      \code{x ++ compress(s)}       & \mathrm{si\ } \code{contains(s, x)} = \code{false} 
    \end{array}
    \right.
  \end{equation*}
  
  \hfill $\lhd$
\item \textbf{Demuestra}, usando tu definición, que:
  \begin{center}
    \code{compress([1, 2, 2, 3, 3, 3]) = [1, 2, 3]}
  \end{center}
\end{itemize}
\begin{proof} Veamos la ejecución de \code{compress} en las siguientes líneas:
  \begin{eqnarray*}
    \code{compress}\big(\code{[1, 2, 2, 3, 3, 3]}\big)
    &=& \code{1 ++ compress}\big(\code{[2, 2, 3, 3, 3]}\big)\\
    &=& \code{1 ++ compress}\big(\code{[2, 3, 3, 3]}\big)\\
    &=& \code{1 ++ 2 ++ compress}\big(\code{[3, 3, 3]}\big)\\
    &=& \code{1 ++ 2 ++ compress}\big(\code{[3, 3]}\big)\\
    &=& \code{1 ++ 2 ++ compress}\big(\code{[3]}\big)\\
    &=& \code{1 ++ 2 ++ 3}\\
    &=& \code{[1, 2, 3]}
  \end{eqnarray*}
  Cabe destacar que por cada llamada a \code{compress(x)} se llama a lo más
  $\frac{|x| \cdot (|x| + 1)}{2}$ veces a la función \code{contains} o al menos $1$ vez.
\end{proof}
\end{document}
